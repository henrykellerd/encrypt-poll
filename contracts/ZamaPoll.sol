// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, ebool, euint32, externalEuint32} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title Zama Encrypted Survey
/// @notice Collects encrypted answers and tracks encrypted counts per question.
contract ZamaPoll is ZamaEthereumConfig {
    uint8 private constant QUESTION_COUNT = 5;
    uint8 private constant MAX_OPTIONS = 4;
    uint8 private constant OPTION_COUNT_Q0 = 3;
    uint8 private constant OPTION_COUNT_Q1 = 4;
    uint8 private constant OPTION_COUNT_Q2 = 3;
    uint8 private constant OPTION_COUNT_Q3 = 3;
    uint8 private constant OPTION_COUNT_Q4 = 3;

    euint32[MAX_OPTIONS][QUESTION_COUNT] private _counts;
    bool[QUESTION_COUNT] private _isPublic;
    mapping(address => mapping(uint8 => bool)) private _hasAnswered;

    event AnswerSubmitted(address indexed respondent, uint8 indexed questionId);
    event ResultsMadePublic(address indexed requester, uint8 indexed questionId);

    error InvalidQuestion();
    error AlreadyAnswered();
    error ResultsAlreadyPublic();

    /// @notice Returns the number of questions in the survey.
    function getQuestionCount() external pure returns (uint8) {
        return QUESTION_COUNT;
    }

    /// @notice Returns the number of options for a question.
    function getOptionCount(uint8 questionId) external pure returns (uint8) {
        return _getOptionCount(questionId);
    }

    /// @notice Returns whether a question has public results.
    function isQuestionPublic(uint8 questionId) external view returns (bool) {
        if (questionId >= QUESTION_COUNT) {
            revert InvalidQuestion();
        }
        return _isPublic[questionId];
    }

    /// @notice Returns whether a user already answered a question.
    function hasAnswered(address user, uint8 questionId) external view returns (bool) {
        if (questionId >= QUESTION_COUNT) {
            revert InvalidQuestion();
        }
        return _hasAnswered[user][questionId];
    }

    /// @notice Returns encrypted counts for a question.
    function getEncryptedCounts(uint8 questionId) external view returns (euint32[MAX_OPTIONS] memory) {
        if (questionId >= QUESTION_COUNT) {
            revert InvalidQuestion();
        }
        return _counts[questionId];
    }

    /// @notice Submits an encrypted answer for a question.
    /// @param questionId The question index.
    /// @param choice The encrypted option index.
    /// @param inputProof The proof generated by the relayer.
    function submitAnswer(uint8 questionId, externalEuint32 choice, bytes calldata inputProof) external {
        if (questionId >= QUESTION_COUNT) {
            revert InvalidQuestion();
        }
        if (_isPublic[questionId]) {
            revert ResultsAlreadyPublic();
        }
        if (_hasAnswered[msg.sender][questionId]) {
            revert AlreadyAnswered();
        }

        euint32 selected = FHE.fromExternal(choice, inputProof);
        _applyAnswer(questionId, selected);

        _hasAnswered[msg.sender][questionId] = true;
        emit AnswerSubmitted(msg.sender, questionId);
    }

    /// @notice Makes encrypted results publicly decryptable for a question.
    function makeResultsPublic(uint8 questionId) external {
        if (questionId >= QUESTION_COUNT) {
            revert InvalidQuestion();
        }
        if (_isPublic[questionId]) {
            revert ResultsAlreadyPublic();
        }

        _isPublic[questionId] = true;
        uint8 optionCount = _getOptionCount(questionId);

        for (uint8 i = 0; i < MAX_OPTIONS; i++) {
            if (i >= optionCount) {
                continue;
            }
            _counts[questionId][i] = FHE.add(_counts[questionId][i], FHE.asEuint32(0));
            FHE.allowThis(_counts[questionId][i]);
            FHE.makePubliclyDecryptable(_counts[questionId][i]);
            FHE.allow(_counts[questionId][i], msg.sender);
        }

        emit ResultsMadePublic(msg.sender, questionId);
    }

    function _applyAnswer(uint8 questionId, euint32 selected) private {
        uint8 optionCount = _getOptionCount(questionId);

        for (uint8 i = 0; i < MAX_OPTIONS; i++) {
            if (i >= optionCount) {
                continue;
            }
            ebool isMatch = FHE.eq(selected, FHE.asEuint32(i));
            euint32 increment = FHE.select(isMatch, FHE.asEuint32(1), FHE.asEuint32(0));
            euint32 updated = FHE.add(_counts[questionId][i], increment);
            _counts[questionId][i] = updated;
            FHE.allowThis(_counts[questionId][i]);
        }
    }

    function _getOptionCount(uint8 questionId) private pure returns (uint8) {
        if (questionId == 0) {
            return OPTION_COUNT_Q0;
        }
        if (questionId == 1) {
            return OPTION_COUNT_Q1;
        }
        if (questionId == 2) {
            return OPTION_COUNT_Q2;
        }
        if (questionId == 3) {
            return OPTION_COUNT_Q3;
        }
        if (questionId == 4) {
            return OPTION_COUNT_Q4;
        }
        revert InvalidQuestion();
    }
}
